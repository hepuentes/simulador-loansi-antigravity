"""
ADMIN_ROUTES.PY - Rutas de administraci√≥n
==========================================
CORREGIDO: 2026-01-18 - Agregadas rutas /admin/seguros y /admin/usuario/eliminar
"""

from flask import render_template, request, redirect, url_for, session, jsonify, flash
from functools import wraps
import json
import traceback

from . import admin_bp


def login_required(f):
    """Decorador que requiere autenticaci√≥n"""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not session.get("autorizado"):
            return redirect(url_for("auth.login"))
        return f(*args, **kwargs)
    return decorated_function


def requiere_permiso(permiso):
    """Decorador que requiere un permiso espec√≠fico"""
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            if not session.get("autorizado"):
                return redirect(url_for("auth.login"))
            
            import sys
            from pathlib import Path
            BASE_DIR = Path(__file__).parent.parent.parent.resolve()
            if str(BASE_DIR) not in sys.path:
                sys.path.insert(0, str(BASE_DIR))
            
            from permisos import tiene_permiso
            
            if not tiene_permiso(permiso):
                if request.is_json or request.path.startswith('/api/'):
                    return jsonify({
                        'error': 'Permiso denegado',
                        'code': 'PERMISSION_DENIED'
                    }), 403
                flash("No tienes permiso para acceder a esta funci√≥n", "error")
                return redirect(url_for("main.dashboard"))
            
            return f(*args, **kwargs)
        return decorated_function
    return decorator


def tiene_alguno_de(permisos_lista):
    """Verifica si el usuario tiene al menos uno de los permisos de la lista"""
    import sys
    from pathlib import Path
    BASE_DIR = Path(__file__).parent.parent.parent.resolve()
    if str(BASE_DIR) not in sys.path:
        sys.path.insert(0, str(BASE_DIR))
    
    from permisos import tiene_permiso
    
    for permiso in permisos_lista:
        if tiene_permiso(permiso):
            return True
    return False


def requiere_rol(*roles_permitidos):
    """Decorador que requiere uno de los roles especificados"""
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            if not session.get("autorizado"):
                return redirect(url_for("auth.login"))
            
            rol_actual = session.get("rol", "asesor")
            if rol_actual not in roles_permitidos:
                flash("No tienes permiso para acceder a esta secci√≥n", "error")
                return redirect(url_for("main.dashboard"))
            
            return f(*args, **kwargs)
        return decorated_function
    return decorator


@admin_bp.route("")
@login_required
@requiere_permiso("admin_panel_acceso")
def admin_panel():
    """Panel principal de administraci√≥n"""
    import sys
    from pathlib import Path
    BASE_DIR = Path(__file__).parent.parent.parent.resolve()
    if str(BASE_DIR) not in sys.path:
        sys.path.insert(0, str(BASE_DIR))

    from db_helpers import cargar_configuracion, cargar_scoring, obtener_usuarios_completos
    from db_helpers_scoring_linea import obtener_lineas_credito_scoring

    config = cargar_configuracion()
    scoring = cargar_scoring()
    usuarios_lista = obtener_usuarios_completos()
    
    # Convertir lista a diccionario indexado por username (formato esperado por template)
    usuarios = {u['username']: u for u in usuarios_lista}

    # Cargar l√≠neas de cr√©dito y FILTRAR solo las v√°lidas
    all_lineas_credito = config.get("LINEAS_CREDITO", {})
    
    # Filtrar l√≠neas de cr√©dito v√°lidas (con campos requeridos)
    lineas_credito = {}
    for nombre, datos in all_lineas_credito.items():
        # Validar que sea un dict y tenga campos m√≠nimos
        if isinstance(datos, dict) and datos.get("monto_min") is not None:
            lineas_credito[nombre] = datos
        else:
            # Log l√≠neas inv√°lidas para debugging
            print(f"‚ö†Ô∏è L√≠nea de cr√©dito '{nombre}' ignorada - datos incompletos o inv√°lidos")
    
    costos_asociados = config.get("COSTOS_ASOCIADOS", {})
    parametros_capacidad = config.get("PARAMETROS_CAPACIDAD_PAGO", {})
    config_comite = config.get("COMITE_CREDITO", {})
    
    # Obtener configuraci√≥n de seguros
    seguros_config = config.get("SEGUROS", {})
    seguro_vida = seguros_config.get("SEGURO_VIDA", [])

    # Obtener l√≠neas con info de scoring
    lineas_scoring = obtener_lineas_credito_scoring()
    
    # Variables para el template admin.html
    scoring_criterios = scoring.get("criterios", {})
    scoring_secciones = scoring.get("secciones", [])
    
    # Preparar scoring_json para JavaScript
    scoring_json = {
        "criterios": scoring_criterios,
        "secciones": scoring_secciones,
        "niveles_riesgo": scoring.get("niveles_riesgo", []),
        "factores_rechazo_automatico": scoring.get("factores_rechazo_automatico", []),
        "puntaje_minimo_aprobacion": scoring.get("puntaje_minimo_aprobacion", 17),
        "dti_maximo": scoring.get("dti_maximo", 40),
        "umbral_mora_telcos_rechazo": scoring.get("umbral_mora_telcos_rechazo", 200000)
    }

    return render_template(
        "admin/admin.html",
        lineas_credito=lineas_credito,
        lineas_scoring=lineas_scoring,
        costos_asociados=costos_asociados,
        usuarios=usuarios,
        parametros_capacidad=parametros_capacidad,
        config_comite=config_comite,
        scoring=scoring,
        scoring_json=scoring_json,
        scoring_criterios=scoring_criterios,
        scoring_secciones=scoring_secciones,
        seguro_vida=seguro_vida
    )


# ============================================================================
# RUTAS DE USUARIOS
# ============================================================================

@admin_bp.route("/usuario/nuevo", methods=["POST"])
@login_required
@requiere_permiso("usr_crear")
def crear_usuario():
    """Crear nuevo usuario"""
    import sys
    from pathlib import Path
    BASE_DIR = Path(__file__).parent.parent.parent.resolve()
    if str(BASE_DIR) not in sys.path:
        sys.path.insert(0, str(BASE_DIR))

    from db_helpers import crear_usuario as db_crear_usuario
    from werkzeug.security import generate_password_hash

    try:
        username = request.form.get("username", "").strip().lower()
        password = request.form.get("password", "")
        rol = request.form.get("rol", "asesor")
        nombre_completo = request.form.get("nombre_completo", "").strip()

        if not username or not password:
            flash("Usuario y contrase√±a son requeridos", "error")
            return redirect(url_for("admin.admin_panel") + "#Usuarios")

        password_hash = generate_password_hash(password)

        if db_crear_usuario(username, password_hash, rol, nombre_completo):
            flash(f"Usuario '{username}' creado exitosamente", "success")
        else:
            flash(f"El usuario '{username}' ya existe", "error")

    except Exception as e:
        flash(f"Error al crear usuario: {str(e)}", "error")

    return redirect(url_for("admin.admin_panel") + "#Usuarios")


@admin_bp.route("/usuario/cambiar-password", methods=["POST"])
@login_required
@requiere_permiso("usr_password")
def cambiar_password():
    """Cambiar contrase√±a de usuario"""
    import sys
    from pathlib import Path
    BASE_DIR = Path(__file__).parent.parent.parent.resolve()
    if str(BASE_DIR) not in sys.path:
        sys.path.insert(0, str(BASE_DIR))

    from database import conectar_db
    from werkzeug.security import generate_password_hash

    try:
        username = request.form.get("username")
        new_password = request.form.get("new_password")

        if not username or not new_password:
            flash("Usuario y nueva contrase√±a son requeridos", "error")
            return redirect(url_for("admin.admin_panel") + "#Usuarios")

        # Actualizar en SQLite
        conn = conectar_db()
        cursor = conn.cursor()
        cursor.execute(
            "UPDATE usuarios SET password_hash = ? WHERE username = ?",
            (generate_password_hash(new_password), username)
        )
        conn.commit()
        conn.close()

        flash(f"Contrase√±a de '{username}' actualizada", "success")

    except Exception as e:
        flash(f"Error al cambiar contrase√±a: {str(e)}", "error")

    return redirect(url_for("admin.admin_panel") + "#Usuarios")


@admin_bp.route("/usuario/eliminar", methods=["POST"])
@login_required
@requiere_permiso("usr_eliminar")
def eliminar_usuario():
    """Eliminar usuario (soft delete)"""
    import sys
    from pathlib import Path
    BASE_DIR = Path(__file__).parent.parent.parent.resolve()
    if str(BASE_DIR) not in sys.path:
        sys.path.insert(0, str(BASE_DIR))

    from db_helpers import eliminar_usuario_db

    try:
        username = request.form.get("username")

        if not username:
            flash("Usuario no especificado", "error")
            return redirect(url_for("admin.admin_panel") + "#Usuarios")

        if username == "admin":
            flash("No se puede eliminar el usuario admin", "error")
            return redirect(url_for("admin.admin_panel") + "#Usuarios")

        if username == session.get("username"):
            flash("No puedes eliminarte a ti mismo", "error")
            return redirect(url_for("admin.admin_panel") + "#Usuarios")

        if eliminar_usuario_db(username):
            flash(f"Usuario '{username}' eliminado correctamente", "success")
        else:
            flash(f"Usuario '{username}' no encontrado o ya est√° inactivo", "warning")

    except Exception as e:
        traceback.print_exc()
        flash(f"Error al eliminar usuario: {str(e)}", "error")

    return redirect(url_for("admin.admin_panel") + "#Usuarios")


# ============================================================================
# RUTAS DE SEGUROS
# ============================================================================

@admin_bp.route("/seguros", methods=["POST"])
@login_required
def actualizar_seguros():
    """Actualizar configuraci√≥n de seguros"""
    import sys
    from pathlib import Path
    BASE_DIR = Path(__file__).parent.parent.parent.resolve()
    if str(BASE_DIR) not in sys.path:
        sys.path.insert(0, str(BASE_DIR))
    
    # Verificar permisos
    if not tiene_alguno_de(["cfg_seguros_editar", "cfg_tasas_editar"]):
        flash("No tienes permiso para editar seguros", "warning")
        return redirect(url_for("admin.admin_panel"))
    
    from db_helpers import cargar_configuracion, guardar_configuracion
    
    try:
        # Obtener todos los rangos del formulario
        rangos_nuevos = []
        i = 0
        
        while True:
            edad_min = request.form.get(f"edad_min_{i}")
            edad_max = request.form.get(f"edad_max_{i}")
            costo = request.form.get(f"costo_{i}")
            descripcion = request.form.get(f"descripcion_{i}")
            
            if not edad_min:  # No hay m√°s rangos
                break
            
            try:
                edad_min = int(edad_min)
                edad_max = int(edad_max)
                # Limpiar formato de moneda
                costo_str = costo.replace(".", "").replace(",", "").replace("$", "").strip()
                costo = int(float(costo_str)) if costo_str else 0
                
                if edad_min < 18 or edad_max > 120:
                    flash("Las edades deben estar entre 18 y 120 a√±os", "error")
                    return redirect(url_for("admin.admin_panel") + "#Seguros")
                
                if edad_min >= edad_max:
                    flash("La edad m√≠nima debe ser menor que la edad m√°xima", "error")
                    return redirect(url_for("admin.admin_panel") + "#Seguros")
                
                if costo < 0:
                    flash("El costo no puede ser negativo", "error")
                    return redirect(url_for("admin.admin_panel") + "#Seguros")
                
                rangos_nuevos.append({
                    "id": i + 1,
                    "edad_min": edad_min,
                    "edad_max": edad_max,
                    "costo": costo,
                    "descripcion": descripcion or f"{edad_min} a {edad_max} a√±os"
                })
                
            except ValueError as ve:
                flash(f"Error en rango {i+1}: valores inv√°lidos - {str(ve)}", "error")
                return redirect(url_for("admin.admin_panel") + "#Seguros")
            
            i += 1
        
        if not rangos_nuevos:
            flash("Debe haber al menos un rango de seguro", "error")
            return redirect(url_for("admin.admin_panel") + "#Seguros")
        
        # Ordenar por edad_min
        rangos_nuevos.sort(key=lambda x: x["edad_min"])
        
        # Validar que no haya solapamientos
        for j in range(len(rangos_nuevos) - 1):
            if rangos_nuevos[j]["edad_max"] >= rangos_nuevos[j + 1]["edad_min"]:
                flash("Los rangos de edad no pueden solaparse", "error")
                return redirect(url_for("admin.admin_panel") + "#Seguros")
        
        # Guardar en configuraci√≥n
        config = cargar_configuracion()
        config["SEGUROS"] = {"SEGURO_VIDA": rangos_nuevos}
        guardar_configuracion(config)
        
        flash("Configuraci√≥n de seguros actualizada correctamente", "success")
        
    except Exception as e:
        traceback.print_exc()
        flash(f"Error al actualizar seguros: {str(e)}", "error")
    
    return redirect(url_for("admin.admin_panel") + "#Seguros")


# ============================================================================
# RUTAS DE HISTORIAL DE EVALUACIONES
# ============================================================================

@admin_bp.route("/historial-evaluaciones")
@login_required
@requiere_permiso("sco_hist_todos")
def historial_evaluaciones():
    """Historial de todas las evaluaciones"""
    import sys
    from pathlib import Path
    BASE_DIR = Path(__file__).parent.parent.parent.resolve()
    if str(BASE_DIR) not in sys.path:
        sys.path.insert(0, str(BASE_DIR))

    from db_helpers import cargar_evaluaciones

    evaluaciones = cargar_evaluaciones()

    # Obtener filtros de la URL
    filtros = {
        'asesor': request.args.get('asesor', ''),
        'desde': request.args.get('desde', ''),
        'hasta': request.args.get('hasta', ''),
        'resultado': request.args.get('resultado', '')
    }

    # Obtener lista de asesores √∫nicos para el filtro
    asesores_disponibles = list(set(e.get('asesor', '') for e in evaluaciones if e.get('asesor')))
    asesores_disponibles.sort()
    
    # Calcular estad√≠sticas para las tarjetas
    total = len(evaluaciones)
    aprobados = sum(1 for e in evaluaciones if e.get('resultado', {}).get('aprobado', False))
    rechazados = total - aprobados
    tasa_aprobacion = round((aprobados / total * 100) if total > 0 else 0)
    
    stats = {
        'total': total,
        'aprobados': aprobados,
        'rechazados': rechazados,
        'tasa_aprobacion': tasa_aprobacion
    }
    
    # Paginaci√≥n
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 20, type=int)
    total_pages = (total + per_page - 1) // per_page if total > 0 else 1
    
    pagination = {
        'page': page,
        'per_page': per_page,
        'total': total,
        'total_pages': total_pages,
        'has_prev': page > 1,
        'has_next': page < total_pages
    }

    return render_template(
        "admin/historial_evaluaciones.html",
        evaluaciones=evaluaciones,
        filtros=filtros,
        asesores=asesores_disponibles,
        asesores_disponibles=asesores_disponibles,
        stats=stats,
        pagination=pagination
    )


# ============================================================================
# RUTAS DE ASIGNACIONES DE EQUIPO
# ============================================================================

@admin_bp.route("/asignaciones-equipo", methods=["GET", "POST"])
@login_required
@requiere_permiso("usr_asignaciones_equipo")
def asignaciones_equipo():
    """Gesti√≥n de asignaciones de equipo"""
    import sys
    from pathlib import Path
    BASE_DIR = Path(__file__).parent.parent.parent.resolve()
    if str(BASE_DIR) not in sys.path:
        sys.path.insert(0, str(BASE_DIR))

    from db_helpers import (
        get_all_assignments, 
        add_assignment, 
        remove_assignment_by_id,
        get_managers_for_assignments,
        get_members_for_assignments
    )

    if request.method == "POST":
        action = request.form.get("action")

        if action == "add":
            manager = request.form.get("manager")
            member = request.form.get("member")

            if manager and member:
                if add_assignment(manager, member):
                    flash(f"Asignaci√≥n creada: {member} ‚Üí {manager}", "success")
                else:
                    flash("Error al crear asignaci√≥n", "error")

        elif action == "remove":
            assignment_id = request.form.get("assignment_id")
            if assignment_id:
                if remove_assignment_by_id(int(assignment_id)):
                    flash("Asignaci√≥n eliminada", "success")
                else:
                    flash("Error al eliminar asignaci√≥n", "error")

        return redirect(url_for("admin.asignaciones_equipo"))

    # GET: mostrar p√°gina
    asignaciones = get_all_assignments()
    managers = get_managers_for_assignments()
    members = get_members_for_assignments()

    return render_template(
        "admin/asignaciones_equipo.html",
        asignaciones=asignaciones,
        managers=managers,
        members=members
    )


# ============================================================================
# RUTAS DE L√çNEAS DE CR√âDITO
# ============================================================================

@admin_bp.route("/lineas", methods=["POST"])
@login_required
def lineas_legacy():
    """
    Legacy route for /admin/lineas POST.
    This route handles inline edits from the admin panel line cards.
    It acts as a proxy to editar_linea_credito.
    """
    print("üìù [LEGACY] POST /admin/lineas called")
    # Delegate to the edit function - the form has tipo_credito as name
    return editar_linea_credito_legacy()


def editar_linea_credito_legacy():
    """Internal function to handle legacy /admin/lineas POST"""
    import sys
    from pathlib import Path
    BASE_DIR = Path(__file__).parent.parent.parent.resolve()
    if str(BASE_DIR) not in sys.path:
        sys.path.insert(0, str(BASE_DIR))
    
    if not tiene_alguno_de(["cfg_lin_editar", "cfg_tasas_editar"]):
        flash("No tienes permiso para editar l√≠neas de cr√©dito", "warning")
        return redirect(url_for("admin.admin_panel"))

    from db_helpers import cargar_configuracion, guardar_configuracion
    from ..utils.formatting import parse_currency_value

    try:
        # The legacy form uses 'tipo_credito' as the line name
        nombre = request.form.get("tipo_credito", "").strip()
        
        print(f"üìù [LEGACY] Editing line: {nombre}")

        if not nombre:
            flash("El nombre de la l√≠nea es requerido", "error")
            return redirect(url_for("admin.admin_panel") + "#TasasCredito")

        config = cargar_configuracion()
        lineas = config.get("LINEAS_CREDITO", {})

        if nombre not in lineas:
            flash(f"L√≠nea '{nombre}' no encontrada", "error")
            return redirect(url_for("admin.admin_panel") + "#TasasCredito")

        # Update the line data from form
        linea_data = lineas[nombre]
        
        # Only update fields that are present in the form
        if request.form.get("descripcion"):
            linea_data["descripcion"] = request.form.get("descripcion")
        if request.form.get("monto_min"):
            linea_data["monto_min"] = parse_currency_value(request.form.get("monto_min"))
        if request.form.get("monto_max"):
            linea_data["monto_max"] = parse_currency_value(request.form.get("monto_max"))
        if request.form.get("plazo_min"):
            linea_data["plazo_min"] = int(request.form.get("plazo_min"))
        if request.form.get("plazo_max"):
            linea_data["plazo_max"] = int(request.form.get("plazo_max"))
        if request.form.get("tasa_mensual"):
            linea_data["tasa_mensual"] = float(request.form.get("tasa_mensual"))
        if request.form.get("tasa_anual"):
            linea_data["tasa_anual"] = float(request.form.get("tasa_anual"))
        if request.form.get("aval_porcentaje"):
            linea_data["aval_porcentaje"] = float(request.form.get("aval_porcentaje"))
        if request.form.get("plazo_tipo"):
            linea_data["plazo_tipo"] = request.form.get("plazo_tipo")
        linea_data["permite_desembolso_neto"] = request.form.get("permite_desembolso_neto") == "on"
        if request.form.get("desembolso_por_defecto"):
            linea_data["desembolso_por_defecto"] = request.form.get("desembolso_por_defecto")

        lineas[nombre] = linea_data
        config["LINEAS_CREDITO"] = lineas
        
        guardar_configuracion(config)
        print(f"‚úÖ [LEGACY] Line '{nombre}' updated successfully")
        flash(f"L√≠nea '{nombre}' actualizada correctamente", "success")

    except Exception as e:
        traceback.print_exc()
        flash(f"Error al editar l√≠nea: {str(e)}", "error")

    return redirect(url_for("admin.admin_panel") + "#TasasCredito")


@admin_bp.route("/lineas/nueva", methods=["POST"])
@login_required
def crear_linea_credito():
    """Crear nueva l√≠nea de cr√©dito"""
    import sys
    from pathlib import Path
    BASE_DIR = Path(__file__).parent.parent.parent.resolve()
    if str(BASE_DIR) not in sys.path:
        sys.path.insert(0, str(BASE_DIR))
    
    if not tiene_alguno_de(["cfg_lin_editar", "cfg_tasas_editar"]):
        flash("No tienes permiso para crear l√≠neas de cr√©dito", "warning")
        return redirect(url_for("admin.admin_panel"))

    from db_helpers import cargar_configuracion, guardar_configuracion
    from db_helpers_scoring_linea import crear_config_scoring_linea_defecto
    from ..utils.formatting import parse_currency_value

    try:
        # Accept both 'nombre' and 'nombre_linea' for frontend compatibility
        nombre = request.form.get("nombre") or request.form.get("nombre_linea", "").strip()
        
        print(f"üìù [CREAR] nombre={nombre}")

        if not nombre:
            flash("El nombre de la l√≠nea es requerido", "error")
            return redirect(url_for("admin.admin_panel") + "#TasasCredito")

        config = cargar_configuracion()
        lineas = config.get("LINEAS_CREDITO", {})

        if nombre in lineas:
            flash(f"La l√≠nea '{nombre}' ya existe", "error")
            return redirect(url_for("admin.admin_panel") + "#TasasCredito")

        # Crear nueva l√≠nea
        tasa_anual = float(request.form.get("tasa_anual", 25))

        lineas[nombre] = {
            "descripcion": request.form.get("descripcion", ""),
            "monto_min": parse_currency_value(request.form.get("monto_min", 500000)),
            "monto_max": parse_currency_value(request.form.get("monto_max", 10000000)),
            "plazo_min": int(request.form.get("plazo_min", 1)),
            "plazo_max": int(request.form.get("plazo_max", 36)),
            "tasa_mensual": float(request.form.get("tasa_mensual", 2.0)),
            "tasa_anual": tasa_anual,
            "aval_porcentaje": float(request.form.get("aval_porcentaje", 0.10)),
            "plazo_tipo": request.form.get("plazo_tipo", "meses"),
            "permite_desembolso_neto": request.form.get("permite_desembolso_neto") == "on",
            "desembolso_por_defecto": request.form.get("desembolso_por_defecto", "completo")
        }

        config["LINEAS_CREDITO"] = lineas
        guardar_configuracion(config)

        # Crear configuraci√≥n de scoring por defecto para la nueva l√≠nea
        from database import conectar_db
        conn = conectar_db()
        cursor = conn.cursor()
        cursor.execute("SELECT id FROM lineas_credito WHERE nombre = ?", (nombre,))
        row = cursor.fetchone()
        conn.close()

        if row:
            linea_id = row[0]
            crear_config_scoring_linea_defecto(linea_id, tasa_anual)

        flash(f"L√≠nea '{nombre}' creada exitosamente", "success")

    except Exception as e:
        traceback.print_exc()
        flash(f"Error al crear l√≠nea: {str(e)}", "error")

    return redirect(url_for("admin.admin_panel") + "#TasasCredito")


    return redirect(url_for("admin.admin_panel") + "#TasasCredito")


@admin_bp.route("/lineas/editar", methods=["POST"])
@login_required
def editar_linea_credito():
    """Editar l√≠nea de cr√©dito existente"""
    import sys
    from pathlib import Path
    BASE_DIR = Path(__file__).parent.parent.parent.resolve()
    if str(BASE_DIR) not in sys.path:
        sys.path.insert(0, str(BASE_DIR))
    
    if not tiene_alguno_de(["cfg_lin_editar", "cfg_tasas_editar"]):
        flash("No tienes permiso para editar l√≠neas de cr√©dito", "warning")
        return redirect(url_for("admin.admin_panel"))

    from db_helpers import cargar_configuracion, guardar_configuracion
    from ..utils.formatting import parse_currency_value

    try:
        # El nombre original viene en un campo oculto o es el mismo nombre si no se permite cambiar
        nombre_original = request.form.get("nombre_original")
        # Accept both 'nombre' and 'nombre_linea' for frontend compatibility
        nombre = request.form.get("nombre") or request.form.get("nombre_linea", "").strip()
        
        print(f"üìù [EDITAR] nombre_original={nombre_original}, nombre={nombre}")

        if not nombre:
            flash("El nombre de la l√≠nea es requerido", "error")
            return redirect(url_for("admin.admin_panel") + "#TasasCredito")

        config = cargar_configuracion()
        lineas = config.get("LINEAS_CREDITO", {})

        # Si el nombre cambi√≥, verificar que no exista ya
        if nombre_original and nombre != nombre_original and nombre in lineas:
            flash(f"La l√≠nea '{nombre}' ya existe", "error")
            return redirect(url_for("admin.admin_panel") + "#TasasCredito")

        # Recuperar datos existentes o crear nuevos
        linea_data = lineas.get(nombre_original, {}) if nombre_original else {}
        if not linea_data and nombre in lineas:
             linea_data = lineas[nombre]

        # Actualizar datos
        linea_data.update({
            "descripcion": request.form.get("descripcion", ""),
            "monto_min": parse_currency_value(request.form.get("monto_min", 500000)),
            "monto_max": parse_currency_value(request.form.get("monto_max", 10000000)),
            "plazo_min": int(request.form.get("plazo_min", 1)),
            "plazo_max": int(request.form.get("plazo_max", 36)),
            "tasa_mensual": float(request.form.get("tasa_mensual", 2.0)),
            "tasa_anual": float(request.form.get("tasa_anual", 25.0)),
            "aval_porcentaje": float(request.form.get("aval_porcentaje", 0.10)),
            "plazo_tipo": request.form.get("plazo_tipo", "meses"),
            "permite_desembolso_neto": request.form.get("permite_desembolso_neto") == "on",
            "desembolso_por_defecto": request.form.get("desembolso_por_defecto", "completo")
        })

        # Si hubo cambio de nombre, eliminar el anterior (soft delete en DB) y poner el nuevo
        if nombre_original and nombre != nombre_original:
            if nombre_original in lineas:
                del lineas[nombre_original]
            
            # CR√çTICO: Eliminar de la BD expl√≠citamente para evitar duplicados
            # ya que guardar_configuracion solo hace INSERT/UPDATE.
            from db_helpers import eliminar_linea_credito_db
            eliminar_linea_credito_db(nombre_original)
        
        lineas[nombre] = linea_data
        config["LINEAS_CREDITO"] = lineas
        
        guardar_configuracion(config)
        flash(f"L√≠nea '{nombre}' actualizada correctamente", "success")

    except Exception as e:
        traceback.print_exc()
        flash(f"Error al editar l√≠nea: {str(e)}", "error")

    return redirect(url_for("admin.admin_panel") + "#TasasCredito")


@admin_bp.route("/lineas/eliminar", methods=["POST"])
@login_required
def eliminar_linea_credito():
    """Eliminar l√≠nea de cr√©dito (soft delete)"""
    import sys
    from pathlib import Path
    BASE_DIR = Path(__file__).parent.parent.parent.resolve()
    if str(BASE_DIR) not in sys.path:
        sys.path.insert(0, str(BASE_DIR))
    
    if not tiene_alguno_de(["cfg_lin_editar", "cfg_tasas_editar"]):
        flash("No tienes permiso para eliminar l√≠neas de cr√©dito", "warning")
        return redirect(url_for("admin.admin_panel"))

    from db_helpers import eliminar_linea_credito_db

    try:
        # Accept both 'nombre' and 'nombre_linea' for backward compatibility
        nombre = request.form.get("nombre") or request.form.get("nombre_linea")

        if not nombre:
            flash("Nombre de l√≠nea no especificado", "error")
            return redirect(url_for("admin.admin_panel") + "#TasasCredito")

        if eliminar_linea_credito_db(nombre):
            flash(f"L√≠nea '{nombre}' eliminada", "success")
        else:
            flash(f"Error al eliminar l√≠nea '{nombre}'", "error")

    except Exception as e:
        flash(f"Error al eliminar l√≠nea: {str(e)}", "error")

    return redirect(url_for("admin.admin_panel") + "#TasasCredito")


@admin_bp.route("/costos", methods=["POST"])
@login_required
@requiere_permiso("cfg_costos_editar")
def guardar_costo():
    """Guardar o actualizar un costo asociado"""
    import sys
    from pathlib import Path
    BASE_DIR = Path(__file__).parent.parent.parent.resolve()
    if str(BASE_DIR) not in sys.path:
        sys.path.insert(0, str(BASE_DIR))

    from db_helpers import cargar_configuracion, guardar_configuracion
    from ..utils.formatting import parse_currency_value

    try:
        linea_nombre = request.form.get("linea")
        nombre_costo = request.form.get("nombre_costo")
        valor = request.form.get("valor")

        if not linea_nombre or not nombre_costo or valor is None:
            flash("Todos los campos son requeridos", "error")
            return redirect(url_for("admin.admin_panel") + "#CostosAsociados")

        config = cargar_configuracion()
        costos = config.get("COSTOS_ASOCIADOS", {})
        
        if linea_nombre not in costos:
            costos[linea_nombre] = {}
        
        costos[linea_nombre][nombre_costo] = parse_currency_value(str(valor))
        config["COSTOS_ASOCIADOS"] = costos
        
        guardar_configuracion(config)
        flash(f"Costo '{nombre_costo}' guardado correctamente", "success")

    except Exception as e:
        traceback.print_exc()
        flash(f"Error al guardar costo: {str(e)}", "error")

    return redirect(url_for("admin.admin_panel") + "#CostosAsociados")


@admin_bp.route("/costos/eliminar", methods=["POST"])
@login_required
@requiere_permiso("cfg_costos_editar")
def eliminar_costo():
    """Eliminar un costo asociado"""
    import sys
    from pathlib import Path
    BASE_DIR = Path(__file__).parent.parent.parent.resolve()
    if str(BASE_DIR) not in sys.path:
        sys.path.insert(0, str(BASE_DIR))

    from db_helpers import cargar_configuracion, guardar_configuracion

    try:
        linea_nombre = request.form.get("linea")
        nombre_costo = request.form.get("nombre_costo")

        if not linea_nombre or not nombre_costo:
            flash("Datos incompletos para eliminar costo", "error")
            return redirect(url_for("admin.admin_panel") + "#CostosAsociados")

        config = cargar_configuracion()
        costos = config.get("COSTOS_ASOCIADOS", {})
        
        if linea_nombre in costos and nombre_costo in costos[linea_nombre]:
            del costos[linea_nombre][nombre_costo]
            # Si la l√≠nea queda sin costos, se puede dejar la llave vac√≠a o eliminarla
            # Dej√©mosla para consistencia
            
            config["COSTOS_ASOCIADOS"] = costos
            guardar_configuracion(config)
            flash(f"Costo '{nombre_costo}' eliminado", "success")
        else:
            flash("Costo no encontrado", "warning")

    except Exception as e:
        traceback.print_exc()
        flash(f"Error al eliminar costo: {str(e)}", "error")

    return redirect(url_for("admin.admin_panel") + "#CostosAsociados")


@admin_bp.route("/capacidad/guardar", methods=["POST"])
@login_required
@requiere_permiso("cfg_capacidad_editar")
def guardar_capacidad():
    """Guardar par√°metros de capacidad de pago"""
    import sys
    from pathlib import Path
    BASE_DIR = Path(__file__).parent.parent.parent.resolve()
    if str(BASE_DIR) not in sys.path:
        sys.path.insert(0, str(BASE_DIR))

    from db_helpers import cargar_configuracion, guardar_configuracion

    try:
        data = request.form
        # Si viene como JSON (fetch)
        if request.is_json:
            data = request.get_json()
        
        # Validar datos recibidos
        try:
            limite_conservador = int(data.get("limite_conservador", 30))
            limite_maximo = int(data.get("limite_maximo", 35))
            limite_absoluto = int(data.get("limite_absoluto", 40))
        except ValueError:
             if request.is_json:
                 return jsonify({"success": False, "error": "Los l√≠mites deben ser n√∫meros enteros"}), 400
             flash("Los l√≠mites deben ser n√∫meros enteros", "error")
             return redirect(url_for("admin.admin_panel") + "#CapacidadPago")

        # Validar rangos
        if not (10 <= limite_conservador <= 50):
             msg = "L√≠mite conservador debe estar entre 10% y 50%"
             if request.is_json:
                 return jsonify({"success": False, "error": msg}), 400
             flash(msg, "error")
             return redirect(url_for("admin.admin_panel") + "#CapacidadPago")

        if not (limite_conservador < limite_maximo < limite_absoluto):
             msg = "Los l√≠mites deben seguir el orden: Conservador < M√°ximo < Absoluto"
             if request.is_json:
                 return jsonify({"success": False, "error": msg}), 400
             flash(msg, "error")
             return redirect(url_for("admin.admin_panel") + "#CapacidadPago")

        if limite_absoluto > 90:
             msg = "El l√≠mite absoluto no puede exceder el 90%"
             if request.is_json:
                 return jsonify({"success": False, "error": msg}), 400
             flash(msg, "error")
             return redirect(url_for("admin.admin_panel") + "#CapacidadPago")

        config = cargar_configuracion()
        params = config.get("PARAMETROS_CAPACIDAD_PAGO", {})
        
        # Actualizar valores
        params["limite_conservador"] = limite_conservador
        params["limite_maximo"] = limite_maximo
        params["limite_absoluto"] = limite_absoluto
        
        config["PARAMETROS_CAPACIDAD_PAGO"] = params
        guardar_configuracion(config)
        
        if request.is_json:
            return jsonify({"success": True, "message": "Par√°metros guardados correctamente"})
        
        flash("Par√°metros de capacidad guardados correctamente", "success")

    except Exception as e:
        traceback.print_exc()
        if request.is_json:
            return jsonify({"success": False, "error": str(e)}), 500
        flash(f"Error al guardar capacidad: {str(e)}", "error")

    return redirect(url_for("admin.admin_panel") + "#CapacidadPago")


# ============================================================================
# RUTAS DE SCORING
# ============================================================================

@admin_bp.route("/scoring/guardar", methods=["POST"])
@login_required
@requiere_permiso("cfg_sco_editar")
def guardar_scoring():
    """Guardar configuraci√≥n de scoring"""
    import sys
    from pathlib import Path
    BASE_DIR = Path(__file__).parent.parent.parent.resolve()
    if str(BASE_DIR) not in sys.path:
        sys.path.insert(0, str(BASE_DIR))

    from db_helpers import guardar_scoring as db_guardar_scoring

    try:
        data = request.get_json()

        if not data:
            return jsonify({"error": "No se recibieron datos"}), 400

        db_guardar_scoring(data)

        return jsonify({
            "success": True,
            "message": "Configuraci√≥n de scoring guardada"
        })

    except Exception as e:
        traceback.print_exc()
        return jsonify({"error": str(e)}), 500


@admin_bp.route("/actualizar_umbral_mora_telcos", methods=["POST"])
@login_required
@requiere_permiso("cfg_sco_editar")
def actualizar_umbral_mora_telcos():
    """Actualizar umbral de mora de telecomunicaciones"""
    import sys
    from pathlib import Path
    BASE_DIR = Path(__file__).parent.parent.parent.resolve()
    if str(BASE_DIR) not in sys.path:
        sys.path.insert(0, str(BASE_DIR))

    from db_helpers import cargar_scoring, guardar_scoring

    try:
        data = request.get_json()
        umbral = data.get("umbral")

        if umbral is None:
            return jsonify({"success": False, "error": "Umbral no especificado"}), 400

        print(f"üìù [ADMIN] Actualizando umbral_mora_telcos a: {umbral}")

        scoring = cargar_scoring()
        scoring["umbral_mora_telcos_rechazo"] = float(umbral)
        guardar_scoring(scoring)

        return jsonify({"success": True, "message": "Umbral actualizado correctamente"})

    except Exception as e:
        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500